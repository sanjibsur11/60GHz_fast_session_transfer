#Debug pins
NET "debug<0>" LOC = "AG27" | IOSTANDARD = LVCMOS25; #pin 0
NET "debug<1>" LOC = "AE26" | IOSTANDARD = LVCMOS25; #pin 1
NET "debug<2>" LOC = "AF26" | IOSTANDARD = LVCMOS25; #pin 2
NET "debug<3>" LOC = "AD25" | IOSTANDARD = LVCMOS25; #pin 3
NET "debug<4>" LOC = "V24" | IOSTANDARD = LVCMOS25; #pin 4
NET "debug<5>" LOC = "AA23" | IOSTANDARD = LVCMOS25; #pin 5
NET "debug<6>" LOC = "AH30" | IOSTANDARD = LVCMOS25; #pin 6
NET "debug<7>" LOC = "AK31" | IOSTANDARD = LVCMOS25 | PULLDOWN; #pin 7
NET "debug<8>" LOC = "AG28" | IOSTANDARD = LVCMOS25 | PULLDOWN; #pin 8
NET "debug_GPIO_out_pin<0>" LOC = "AE27" | IOSTANDARD = LVCMOS25; #pin 9
NET "debug_GPIO_out_pin<1>" LOC = "AF28" | IOSTANDARD = LVCMOS25; #pin 10
NET "debug_GPIO_out_pin<2>" LOC = "AJ29" | IOSTANDARD = LVCMOS25; #pin 11
NET "debug_GPIO_out_pin<3>" LOC = "AH29" | IOSTANDARD = LVCMOS25; #pin 12
NET "tx_running_d0_pin" LOC = "AL30" | IOSTANDARD = LVCMOS25; #pin 13
#NET "X" LOC = "AM31" | IOSTANDARD = LVCMOS25; #pin 14
NET "debug_chipscopetrig_pin" LOC = "AP32" |  IOSTANDARD = LVCMOS25 | PULLDOWN; #pin 15

#User IO
Net USERIO_hexdisp_left_pin<0> LOC=AL33  |  IOSTANDARD = LVCMOS25;
Net USERIO_hexdisp_left_pin<1> LOC=AK33  |  IOSTANDARD = LVCMOS25;
Net USERIO_hexdisp_left_pin<2> LOC=AH32  |  IOSTANDARD = LVCMOS25;
Net USERIO_hexdisp_left_pin<3> LOC=AF29  |  IOSTANDARD = LVCMOS25;
Net USERIO_hexdisp_left_pin<4> LOC=AE29  |  IOSTANDARD = LVCMOS25;
Net USERIO_hexdisp_left_pin<5> LOC=AK32  |  IOSTANDARD = LVCMOS25;
Net USERIO_hexdisp_left_pin<6> LOC=AF30  |  IOSTANDARD = LVCMOS25;
Net USERIO_hexdisp_right_pin<0> LOC=AE28  |  IOSTANDARD = LVCMOS25;
Net USERIO_hexdisp_right_pin<1> LOC=AD26  |  IOSTANDARD = LVCMOS25;
Net USERIO_hexdisp_right_pin<2> LOC=AC24  |  IOSTANDARD = LVCMOS25;
Net USERIO_hexdisp_right_pin<3> LOC=AE23  |  IOSTANDARD = LVCMOS25;
Net USERIO_hexdisp_right_pin<4> LOC=AC22  |  IOSTANDARD = LVCMOS25;
Net USERIO_hexdisp_right_pin<5> LOC=AD27  |  IOSTANDARD = LVCMOS25;
Net USERIO_hexdisp_right_pin<6> LOC=AB23  |  IOSTANDARD = LVCMOS25;
Net USERIO_hexdisp_left_dp_pin LOC=AG30  |  IOSTANDARD = LVCMOS25;
Net USERIO_hexdisp_right_dp_pin LOC=AC23  |  IOSTANDARD = LVCMOS25;
Net USERIO_leds_red_pin<0> LOC=AN34  |  IOSTANDARD = LVCMOS25; #LSB is bottom LED
Net USERIO_leds_red_pin<1> LOC=AM33  |  IOSTANDARD = LVCMOS25;
Net USERIO_leds_red_pin<2> LOC=AN33  |  IOSTANDARD = LVCMOS25;
Net USERIO_leds_red_pin<3> LOC=AP33  |  IOSTANDARD = LVCMOS25; #MSB is top LED
Net USERIO_leds_green_pin<0> LOC=AD22  |  IOSTANDARD = LVCMOS25; #LSB is bottom LED
Net USERIO_leds_green_pin<1> LOC=AE22  |  IOSTANDARD = LVCMOS25;
Net USERIO_leds_green_pin<2> LOC=AM32  |  IOSTANDARD = LVCMOS25;
Net USERIO_leds_green_pin<3> LOC=AN32  |  IOSTANDARD = LVCMOS25; #MSB is top LED
Net USERIO_rfa_led_red_pin LOC=AL34  |  IOSTANDARD = LVCMOS25;
Net USERIO_rfa_led_green_pin LOC=AK34  |  IOSTANDARD = LVCMOS25;
Net USERIO_rfb_led_red_pin LOC=AJ34  |  IOSTANDARD = LVCMOS25;
Net USERIO_rfb_led_green_pin LOC=AH34  |  IOSTANDARD = LVCMOS25;
Net USERIO_dipsw_pin<3> LOC=AM22  |  IOSTANDARD = LVCMOS15; #MSB is left-most switch
Net USERIO_dipsw_pin<2> LOC=AL23  |  IOSTANDARD = LVCMOS15;
Net USERIO_dipsw_pin<1> LOC=AM23  |  IOSTANDARD = LVCMOS15;
Net USERIO_dipsw_pin<0> LOC=AN23  |  IOSTANDARD = LVCMOS15; #LSB is right-most switch
Net USERIO_pb_u_pin LOC=AM21  |  IOSTANDARD = LVCMOS15;
Net USERIO_pb_m_pin LOC=AN22  |  IOSTANDARD = LVCMOS15;
Net USERIO_pb_d_pin LOC=AP22  |  IOSTANDARD = LVCMOS15;

#USB UART on WARP v3 rev 1.1
Net UART_USB_TX_pin LOC = H9  |  IOSTANDARD=LVCMOS25; #FT230X RXD pin
Net UART_USB_RX_pin LOC = J9  |  IOSTANDARD=LVCMOS25; #FT230X TXD pin

#IIC EEPROM
Net IIC_EEPROM_iic_sda_pin LOC = AG23  |  IOSTANDARD=LVCMOS25;
Net IIC_EEPROM_iic_scl_pin LOC = AF23  |  IOSTANDARD=LVCMOS25;

#ETH A
Net ETH_A_TemacPhy_RST_n_pin LOC=L9  |  IOSTANDARD = LVCMOS25  |  TIG;
Net ETH_A_RGMII_TXD_0_pin<0> LOC=AF9  |  IOSTANDARD = LVCMOS25;
Net ETH_A_RGMII_TXD_0_pin<1> LOC=AF10  |  IOSTANDARD = LVCMOS25;
Net ETH_A_RGMII_TXD_0_pin<2> LOC=AD9  |  IOSTANDARD = LVCMOS25;
Net ETH_A_RGMII_TXD_0_pin<3> LOC=AD10  |  IOSTANDARD = LVCMOS25;
Net ETH_A_RGMII_TX_CTL_0_pin LOC=AG8  |  IOSTANDARD = LVCMOS25;
Net ETH_A_RGMII_TXC_0_pin LOC=AE9  |  IOSTANDARD = LVCMOS25;
Net ETH_A_RGMII_RXD_0_pin<0> LOC=AK9  |  IOSTANDARD = LVCMOS25;
Net ETH_A_RGMII_RXD_0_pin<1> LOC=AJ9  |  IOSTANDARD = LVCMOS25;
Net ETH_A_RGMII_RXD_0_pin<2> LOC=AH8  |  IOSTANDARD = LVCMOS25;
Net ETH_A_RGMII_RXD_0_pin<3> LOC=AH9  |  IOSTANDARD = LVCMOS25;
Net ETH_A_RGMII_RX_CTL_0_pin LOC=AL9  |  IOSTANDARD = LVCMOS25;
Net ETH_A_RGMII_RXC_0_pin LOC=AC10  |  IOSTANDARD = LVCMOS25;
#Fix for errata in rev 1.1 schematics
Net ETH_A_MDC_0_pin LOC=AK8  |  IOSTANDARD = LVCMOS25;
Net ETH_A_MDIO_0_pin LOC=AP9  |  IOSTANDARD = LVCMOS25 | PULLUP;

#ETH B
Net ETH_B_RGMII_TXD_0_pin<0> LOC=M10  |  IOSTANDARD = LVCMOS25;
Net ETH_B_RGMII_TXD_0_pin<1> LOC=B8  |  IOSTANDARD = LVCMOS25;
Net ETH_B_RGMII_TXD_0_pin<2> LOC=AC9  |  IOSTANDARD = LVCMOS25;
Net ETH_B_RGMII_TXD_0_pin<3> LOC=E9  |  IOSTANDARD = LVCMOS25;
Net ETH_B_RGMII_TX_CTL_0_pin LOC=D10  |  IOSTANDARD = LVCMOS25;
Net ETH_B_RGMII_TXC_0_pin LOC=AB10  |  IOSTANDARD = LVCMOS25;
Net ETH_B_RGMII_RXD_0_pin<0> LOC=A9  |  IOSTANDARD = LVCMOS25;
Net ETH_B_RGMII_RXD_0_pin<1> LOC=D9  |  IOSTANDARD = LVCMOS25;
Net ETH_B_RGMII_RXD_0_pin<2> LOC=C9  |  IOSTANDARD = LVCMOS25;
Net ETH_B_RGMII_RXD_0_pin<3> LOC=F10  |  IOSTANDARD = LVCMOS25;
Net ETH_B_RGMII_RX_CTL_0_pin LOC=A8  |  IOSTANDARD = LVCMOS25;
Net ETH_B_RGMII_RXC_0_pin LOC=L10  |  IOSTANDARD = LVCMOS25;
Net ETH_B_MDC_0_pin LOC=AN9  |  IOSTANDARD = LVCMOS25;
Net ETH_B_MDIO_0_pin LOC=AL8  |  IOSTANDARD = LVCMOS25;

#DDR3 SO-DIMM
Net DDR3_2GB_SODIMM_Clk_pin LOC=AC15  |  IOSTANDARD = DIFF_SSTL15;
Net DDR3_2GB_SODIMM_Clk_n_pin LOC=AD15  |  IOSTANDARD = DIFF_SSTL15;
Net DDR3_2GB_SODIMM_CE_pin LOC=AF18  |  IOSTANDARD = SSTL15;
Net DDR3_2GB_SODIMM_CS_n_pin LOC=AL16  |  IOSTANDARD = SSTL15;
Net DDR3_2GB_SODIMM_ODT_pin LOC=AP15  |  IOSTANDARD = SSTL15;
Net DDR3_2GB_SODIMM_RAS_n_pin LOC=AM16  |  IOSTANDARD = SSTL15;
Net DDR3_2GB_SODIMM_CAS_n_pin LOC=AJ17  |  IOSTANDARD = SSTL15;
Net DDR3_2GB_SODIMM_WE_n_pin LOC=AF15  |  IOSTANDARD = SSTL15;
Net DDR3_2GB_SODIMM_BankAddr_pin<0> LOC=AG15  |  IOSTANDARD = SSTL15;
Net DDR3_2GB_SODIMM_BankAddr_pin<1> LOC=AP16  |  IOSTANDARD = SSTL15;
Net DDR3_2GB_SODIMM_BankAddr_pin<2> LOC=AD17  |  IOSTANDARD = SSTL15;
Net DDR3_2GB_SODIMM_Addr_pin<0> LOC=AM17  |  IOSTANDARD = SSTL15;
Net DDR3_2GB_SODIMM_Addr_pin<1> LOC=AF16  |  IOSTANDARD = SSTL15;
Net DDR3_2GB_SODIMM_Addr_pin<2> LOC=AN17  |  IOSTANDARD = SSTL15;
Net DDR3_2GB_SODIMM_Addr_pin<3> LOC=AG17  |  IOSTANDARD = SSTL15;
Net DDR3_2GB_SODIMM_Addr_pin<4> LOC=AK16  |  IOSTANDARD = SSTL15;
Net DDR3_2GB_SODIMM_Addr_pin<5> LOC=AG16  |  IOSTANDARD = SSTL15;
Net DDR3_2GB_SODIMM_Addr_pin<6> LOC=AK17  |  IOSTANDARD = SSTL15;
Net DDR3_2GB_SODIMM_Addr_pin<7> LOC=AG18  |  IOSTANDARD = SSTL15;
Net DDR3_2GB_SODIMM_Addr_pin<8> LOC=AE16  |  IOSTANDARD = SSTL15;
Net DDR3_2GB_SODIMM_Addr_pin<9> LOC=AD16  |  IOSTANDARD = SSTL15;
Net DDR3_2GB_SODIMM_Addr_pin<10> LOC=AH15  |  IOSTANDARD = SSTL15;
Net DDR3_2GB_SODIMM_Addr_pin<11> LOC=AH18  |  IOSTANDARD = SSTL15;
Net DDR3_2GB_SODIMM_Addr_pin<12> LOC=AE17  |  IOSTANDARD = SSTL15;
Net DDR3_2GB_SODIMM_Addr_pin<13> LOC=AJ16  |  IOSTANDARD = SSTL15;
Net DDR3_2GB_SODIMM_Addr_pin<14> LOC=AK18  |  IOSTANDARD = SSTL15;
Net DDR3_2GB_SODIMM_DQ_pin<0> LOC=AK29  |  IOSTANDARD = SSTL15_T_DCI;
Net DDR3_2GB_SODIMM_DQ_pin<1> LOC=AN30  |  IOSTANDARD = SSTL15_T_DCI;
Net DDR3_2GB_SODIMM_DQ_pin<2> LOC=AL29  |  IOSTANDARD = SSTL15_T_DCI;
Net DDR3_2GB_SODIMM_DQ_pin<3> LOC=AN29  |  IOSTANDARD = SSTL15_T_DCI;
Net DDR3_2GB_SODIMM_DQ_pin<4> LOC=AP31  |  IOSTANDARD = SSTL15_T_DCI;
Net DDR3_2GB_SODIMM_DQ_pin<5> LOC=AP30  |  IOSTANDARD = SSTL15_T_DCI;
Net DDR3_2GB_SODIMM_DQ_pin<6> LOC=AH28  |  IOSTANDARD = SSTL15_T_DCI;
Net DDR3_2GB_SODIMM_DQ_pin<7> LOC=AH27  |  IOSTANDARD = SSTL15_T_DCI;
Net DDR3_2GB_SODIMM_DQ_pin<8> LOC=AK28  |  IOSTANDARD = SSTL15_T_DCI;
Net DDR3_2GB_SODIMM_DQ_pin<9> LOC=AL28  |  IOSTANDARD = SSTL15_T_DCI;
Net DDR3_2GB_SODIMM_DQ_pin<10> LOC=AJ27  |  IOSTANDARD = SSTL15_T_DCI;
Net DDR3_2GB_SODIMM_DQ_pin<11> LOC=AH25  |  IOSTANDARD = SSTL15_T_DCI;
Net DDR3_2GB_SODIMM_DQ_pin<12> LOC=AP29  |  IOSTANDARD = SSTL15_T_DCI;
Net DDR3_2GB_SODIMM_DQ_pin<13> LOC=AM27  |  IOSTANDARD = SSTL15_T_DCI;
Net DDR3_2GB_SODIMM_DQ_pin<14> LOC=AJ25  |  IOSTANDARD = SSTL15_T_DCI;
Net DDR3_2GB_SODIMM_DQ_pin<15> LOC=AH24  |  IOSTANDARD = SSTL15_T_DCI;
Net DDR3_2GB_SODIMM_DQ_pin<16> LOC=AJ24  |  IOSTANDARD = SSTL15_T_DCI;
Net DDR3_2GB_SODIMM_DQ_pin<17> LOC=AK24  |  IOSTANDARD = SSTL15_T_DCI;
Net DDR3_2GB_SODIMM_DQ_pin<18> LOC=AL24  |  IOSTANDARD = SSTL15_T_DCI;
Net DDR3_2GB_SODIMM_DQ_pin<19> LOC=AK23  |  IOSTANDARD = SSTL15_T_DCI;
Net DDR3_2GB_SODIMM_DQ_pin<20> LOC=AP27  |  IOSTANDARD = SSTL15_T_DCI;
Net DDR3_2GB_SODIMM_DQ_pin<21> LOC=AM26  |  IOSTANDARD = SSTL15_T_DCI;
Net DDR3_2GB_SODIMM_DQ_pin<22> LOC=AN25  |  IOSTANDARD = SSTL15_T_DCI;
Net DDR3_2GB_SODIMM_DQ_pin<23> LOC=AN24  |  IOSTANDARD = SSTL15_T_DCI;
Net DDR3_2GB_SODIMM_DQ_pin<24> LOC=AD21  |  IOSTANDARD = SSTL15_T_DCI;
Net DDR3_2GB_SODIMM_DQ_pin<25> LOC=AE21  |  IOSTANDARD = SSTL15_T_DCI;
Net DDR3_2GB_SODIMM_DQ_pin<26> LOC=AK22  |  IOSTANDARD = SSTL15_T_DCI;
Net DDR3_2GB_SODIMM_DQ_pin<27> LOC=AL18  |  IOSTANDARD = SSTL15_T_DCI;
Net DDR3_2GB_SODIMM_DQ_pin<28> LOC=AN19  |  IOSTANDARD = SSTL15_T_DCI;
Net DDR3_2GB_SODIMM_DQ_pin<29> LOC=AP19  |  IOSTANDARD = SSTL15_T_DCI;
Net DDR3_2GB_SODIMM_DQ_pin<30> LOC=AM18  |  IOSTANDARD = SSTL15_T_DCI;
Net DDR3_2GB_SODIMM_DQ_pin<31> LOC=AN18  |  IOSTANDARD = SSTL15_T_DCI;
Net DDR3_2GB_SODIMM_DM_pin<0> LOC=AM30  |  IOSTANDARD = SSTL15;
Net DDR3_2GB_SODIMM_DM_pin<1> LOC=AL26  |  IOSTANDARD = SSTL15;
Net DDR3_2GB_SODIMM_DM_pin<2> LOC=AP26  |  IOSTANDARD = SSTL15;
Net DDR3_2GB_SODIMM_DM_pin<3> LOC=AJ22  |  IOSTANDARD = SSTL15;
Net DDR3_2GB_SODIMM_Reset_n_pin LOC=AP17  |  IOSTANDARD = SSTL15;
Net DDR3_2GB_SODIMM_DQS_pin<0> LOC=AG25  |  IOSTANDARD = DIFF_SSTL15_T_DCI;
Net DDR3_2GB_SODIMM_DQS_pin<1> LOC=AN28  |  IOSTANDARD = DIFF_SSTL15_T_DCI;
Net DDR3_2GB_SODIMM_DQS_pin<2> LOC=AM25  |  IOSTANDARD = DIFF_SSTL15_T_DCI;
Net DDR3_2GB_SODIMM_DQS_pin<3> LOC=AG22  |  IOSTANDARD = DIFF_SSTL15_T_DCI;
Net DDR3_2GB_SODIMM_DQS_n_pin<0> LOC=AG26  |  IOSTANDARD = DIFF_SSTL15_T_DCI;
Net DDR3_2GB_SODIMM_DQS_n_pin<1> LOC=AM28  |  IOSTANDARD = DIFF_SSTL15_T_DCI;
Net DDR3_2GB_SODIMM_DQS_n_pin<2> LOC=AL25  |  IOSTANDARD = DIFF_SSTL15_T_DCI;
Net DDR3_2GB_SODIMM_DQS_n_pin<3> LOC=AH22  |  IOSTANDARD = DIFF_SSTL15_T_DCI;

#System clock (80MHz, from sampling clock buffer)
NET samp_clk_n_pin LOC = V23 | IOSTANDARD = LVDS_25 | DIFF_TERM = TRUE;
NET samp_clk_p_pin LOC = U23 | IOSTANDARD = LVDS_25 | DIFF_TERM = TRUE;
Net samp_clk_p_pin TNM_NET = samp_clk_pin;
TIMESPEC TS_samp_clk_pin = PERIOD samp_clk_pin 80000 kHz;

#System clock (200MHz, from LVDS oscillator)
Net osc200_p_pin LOC = A10  |  IOSTANDARD=LVDS_25  |  DIFF_TERM = TRUE;
Net osc200_n_pin LOC = B10  |  IOSTANDARD=LVDS_25  |  DIFF_TERM = TRUE;
Net osc200_p_pin TNM_NET = osc200_p_pin;
TIMESPEC TS_osc200_p_pin = PERIOD osc200_p_pin 200000 kHz;

#Processor reset (RESET button on board)
Net rst_1_sys_rst_pin LOC = AH13  |  IOSTANDARD=LVCMOS15  |  TIG;
Net rst_1_sys_rst_pin TIG;

INST clock_generator_MPMC_Clocks/*/MMCM0_INST*/MMCM_ADV_inst LOC = MMCM_ADV_X0Y2;

#######################################
#MAX2829 transceivers and RF front end
NET RFA_SPI_SCLK_pin LOC=T34 | IOSTANDARD=LVCMOS25;
NET RFA_SPI_MOSI_pin LOC=T33 | IOSTANDARD=LVCMOS25;
NET RFA_SPI_CSn_pin LOC=U32 | IOSTANDARD=LVCMOS25;
NET RFA_SHDN_pin LOC=U27 | IOSTANDARD=LVCMOS25;
NET RFA_TxEn_pin LOC=T31 | IOSTANDARD=LVCMOS25;
NET RFA_RxEn_pin LOC=U33 | IOSTANDARD=LVCMOS25;
NET RFA_RxHP_pin LOC=AG32 | IOSTANDARD=LVCMOS25;
NET RFA_PAEn_24_pin LOC=U25 | IOSTANDARD=LVCMOS25;
NET RFA_PAEn_5_pin LOC=U28 | IOSTANDARD=LVCMOS25;
NET RFA_ANTSW_pin<0> LOC=U31 | IOSTANDARD=LVCMOS25;
NET RFA_ANTSW_pin<1> LOC=U30 | IOSTANDARD=LVCMOS25;
NET RFA_LD_pin LOC=U26 | IOSTANDARD=LVCMOS25;
NET RFA_B_pin<0> LOC=AG33 | IOSTANDARD=LVCMOS25;
NET RFA_B_pin<1> LOC=AF31 | IOSTANDARD=LVCMOS25;
NET RFA_B_pin<2> LOC=AF33 | IOSTANDARD=LVCMOS25;
NET RFA_B_pin<3> LOC=AG31 | IOSTANDARD=LVCMOS25;
NET RFA_B_pin<4> LOC=AF34 | IOSTANDARD=LVCMOS25;
NET RFA_B_pin<5> LOC=AE33 | IOSTANDARD=LVCMOS25;
NET RFA_B_pin<6> LOC=AE34 | IOSTANDARD=LVCMOS25;

NET RFB_SPI_SCLK_pin LOC=H34 | IOSTANDARD=LVCMOS25;
NET RFB_SPI_MOSI_pin LOC=H33 | IOSTANDARD=LVCMOS25;
NET RFB_SPI_CSn_pin LOC=J32 | IOSTANDARD=LVCMOS25;
NET RFB_SHDN_pin LOC=J34 | IOSTANDARD=LVCMOS25;
NET RFB_TxEn_pin LOC=H32 | IOSTANDARD=LVCMOS25;
NET RFB_RxEn_pin LOC=J31 | IOSTANDARD=LVCMOS25;
NET RFB_RxHP_pin LOC=R28 | IOSTANDARD=LVCMOS25;
NET RFB_PAEn_24_pin LOC=T25 | IOSTANDARD=LVCMOS25;
NET RFB_PAEn_5_pin LOC=T28 | IOSTANDARD=LVCMOS25;
NET RFB_ANTSW_pin<0> LOC=T30 | IOSTANDARD=LVCMOS25;
NET RFB_ANTSW_pin<1> LOC=T29 | IOSTANDARD=LVCMOS25;
NET RFB_LD_pin LOC=K33 | IOSTANDARD=LVCMOS25;
NET RFB_B_pin<0> LOC=P27 | IOSTANDARD=LVCMOS25;
NET RFB_B_pin<1> LOC=R27 | IOSTANDARD=LVCMOS25;
NET RFB_B_pin<2> LOC=R29 | IOSTANDARD=LVCMOS25;
NET RFB_B_pin<3> LOC=R26 | IOSTANDARD=LVCMOS25;
NET RFB_B_pin<4> LOC=R32 | IOSTANDARD=LVCMOS25;
NET RFB_B_pin<5> LOC=T26 | IOSTANDARD=LVCMOS25;
NET RFB_B_pin<6> LOC=R31 | IOSTANDARD=LVCMOS25;

NET RFA_AD_spi_sclk_pin LOC = AB33 | IOSTANDARD = LVCMOS25;#
NET RFA_AD_spi_sdio LOC = AC30 | IOSTANDARD = LVCMOS25;#
NET RFA_AD_spi_cs_n_pin LOC = AB31 | IOSTANDARD = LVCMOS25;#
NET RFA_AD_reset_n_pin LOC = AA34 | IOSTANDARD = LVCMOS25;#

NET RFB_AD_spi_sclk_pin LOC = P32 | IOSTANDARD = LVCMOS25;#
NET RFB_AD_spi_sdio LOC = P34 | IOSTANDARD = LVCMOS25;#
NET RFB_AD_spi_cs_n_pin LOC = N32 | IOSTANDARD = LVCMOS25;#
NET RFB_AD_reset_n_pin LOC = N34 | IOSTANDARD = LVCMOS25;#

NET clk_rfref_spi_sclk_pin LOC = V25 | IOSTANDARD = LVCMOS25;#
NET clk_rfref_spi_mosi_pin LOC = W25 | IOSTANDARD = LVCMOS25;#
NET clk_rfref_spi_cs_n_pin LOC = W27 | IOSTANDARD = LVCMOS25;#
NET clk_rfref_spi_miso_pin LOC = Y27 | IOSTANDARD = LVCMOS25;#
NET clk_rfref_func_pin LOC = L26 | IOSTANDARD = LVCMOS25;

NET clk_samp_spi_sclk_pin LOC = W32 | IOSTANDARD = LVCMOS25;#
NET clk_samp_spi_mosi_pin LOC = Y29 | IOSTANDARD = LVCMOS25;#
NET clk_samp_spi_cs_n_pin LOC = W31 | IOSTANDARD = LVCMOS25;#
NET clk_samp_spi_miso_pin LOC = Y28 | IOSTANDARD = LVCMOS25;#
NET clk_samp_func_pin LOC = R33 | IOSTANDARD = LVCMOS25;#

#TRXCLK pins driven by AD9963's; assuming 80MHz worst case
Net RFA_AD_TRXCLK TNM_NET = RFA_AD_TRXCLK;
TIMESPEC TS_RFA_AD_TRXCLK = PERIOD RFA_AD_TRXCLK 80 MHz;

Net RFB_AD_TRXCLK TNM_NET = RFB_AD_TRXCLK;
TIMESPEC TS_RFB_AD_TRXCLK = PERIOD RFB_AD_TRXCLK 80 MHz;

#RFA AD9963
NET RFA_AD_TRXD<0> LOC = AC25 | IOSTANDARD = LVCMOS25;
NET RFA_AD_TRXD<1> LOC = AB25 | IOSTANDARD = LVCMOS25;
NET RFA_AD_TRXD<2> LOC = AB32 | IOSTANDARD = LVCMOS25;
NET RFA_AD_TRXD<3> LOC = AC29 | IOSTANDARD = LVCMOS25;
NET RFA_AD_TRXD<4> LOC = AD29 | IOSTANDARD = LVCMOS25;
NET RFA_AD_TRXD<5> LOC = AC33 | IOSTANDARD = LVCMOS25;
NET RFA_AD_TRXD<6> LOC = AD34 | IOSTANDARD = LVCMOS25;
NET RFA_AD_TRXD<7> LOC = AC32 | IOSTANDARD = LVCMOS25;
NET RFA_AD_TRXD<8> LOC = AD31 | IOSTANDARD = LVCMOS25;
NET RFA_AD_TRXD<9> LOC = AD32 | IOSTANDARD = LVCMOS25;
NET RFA_AD_TRXD<10> LOC = AE31 | IOSTANDARD = LVCMOS25;
NET RFA_AD_TRXD<11> LOC = AE32 | IOSTANDARD = LVCMOS25;

NET RFA_AD_TRXCLK LOC = AD30 | IOSTANDARD = LVCMOS25;
NET RFA_AD_TRXIQ LOC = AC34 | IOSTANDARD = LVCMOS25;

NET RFA_AD_TXCLK LOC = AA31 | IOSTANDARD = LVCMOS25;
NET RFA_AD_TXIQ LOC = AA33 | IOSTANDARD = LVCMOS25;

NET RFA_AD_TXD<0> LOC = AA25 | IOSTANDARD = LVCMOS25;
NET RFA_AD_TXD<1> LOC = AB26 | IOSTANDARD = LVCMOS25;
NET RFA_AD_TXD<2> LOC = Y26 | IOSTANDARD = LVCMOS25;
NET RFA_AD_TXD<3> LOC = AA26 | IOSTANDARD = LVCMOS25;
NET RFA_AD_TXD<4> LOC = AA28 | IOSTANDARD = LVCMOS25;
NET RFA_AD_TXD<5> LOC = AA29 | IOSTANDARD = LVCMOS25;
NET RFA_AD_TXD<6> LOC = AA30 | IOSTANDARD = LVCMOS25;
NET RFA_AD_TXD<7> LOC = AB30 | IOSTANDARD = LVCMOS25;
NET RFA_AD_TXD<8> LOC = AB28 | IOSTANDARD = LVCMOS25;
NET RFA_AD_TXD<9> LOC = AB27 | IOSTANDARD = LVCMOS25;
NET RFA_AD_TXD<10> LOC = AC28 | IOSTANDARD = LVCMOS25;
NET RFA_AD_TXD<11> LOC = AC27 | IOSTANDARD = LVCMOS25;

#RFB
NET RFB_AD_TRXD<0> LOC = N25 | IOSTANDARD = LVCMOS25;
NET RFB_AD_TRXD<1> LOC = M25 | IOSTANDARD = LVCMOS25;
NET RFB_AD_TRXD<2> LOC = N28 | IOSTANDARD = LVCMOS25;
NET RFB_AD_TRXD<3> LOC = N27 | IOSTANDARD = LVCMOS25;
NET RFB_AD_TRXD<4> LOC = P29 | IOSTANDARD = LVCMOS25;
NET RFB_AD_TRXD<5> LOC = M30 | IOSTANDARD = LVCMOS25;
NET RFB_AD_TRXD<6> LOC = N30 | IOSTANDARD = LVCMOS25;
NET RFB_AD_TRXD<7> LOC = N29 | IOSTANDARD = LVCMOS25;
NET RFB_AD_TRXD<8> LOC = P26 | IOSTANDARD = LVCMOS25;
NET RFB_AD_TRXD<9> LOC = P31 | IOSTANDARD = LVCMOS25;
NET RFB_AD_TRXD<10> LOC = P25 | IOSTANDARD = LVCMOS25;
NET RFB_AD_TRXD<11> LOC = P30 | IOSTANDARD = LVCMOS25;

NET RFB_AD_TRXCLK LOC = N33 | IOSTANDARD = LVCMOS25;
NET RFB_AD_TRXIQ LOC = M33 | IOSTANDARD = LVCMOS25;

NET RFB_AD_TXCLK LOC = L28 | IOSTANDARD = LVCMOS25;
NET RFB_AD_TXIQ LOC = L29 | IOSTANDARD = LVCMOS25;

NET RFB_AD_TXD<0> LOC = K32 | IOSTANDARD = LVCMOS25;
NET RFB_AD_TXD<1> LOC = M26 | IOSTANDARD = LVCMOS25;
NET RFB_AD_TXD<2> LOC = M32 | IOSTANDARD = LVCMOS25;
NET RFB_AD_TXD<3> LOC = K34 | IOSTANDARD = LVCMOS25;
NET RFB_AD_TXD<4> LOC = M31 | IOSTANDARD = LVCMOS25;
NET RFB_AD_TXD<5> LOC = L30 | IOSTANDARD = LVCMOS25;
NET RFB_AD_TXD<6> LOC = L33 | IOSTANDARD = LVCMOS25;
NET RFB_AD_TXD<7> LOC = L31 | IOSTANDARD = LVCMOS25;
NET RFB_AD_TXD<8> LOC = M28 | IOSTANDARD = LVCMOS25;
NET RFB_AD_TXD<9> LOC = L34 | IOSTANDARD = LVCMOS25;
NET RFB_AD_TXD<10> LOC = M27 | IOSTANDARD = LVCMOS25;
NET RFB_AD_TXD<11> LOC = K31 | IOSTANDARD = LVCMOS25;

NET RF_RSSI_CLK LOC = B32 | IOSTANDARD = LVCMOS25;
NET RF_RSSI_PD LOC = B34 | IOSTANDARD = LVCMOS25;
NET RFB_RSSI_D<0> LOC = A33 | IOSTANDARD = LVCMOS25;
NET RFB_RSSI_D<1> LOC = B33 | IOSTANDARD = LVCMOS25;
NET RFB_RSSI_D<2> LOC = C33 | IOSTANDARD = LVCMOS25;
NET RFB_RSSI_D<3> LOC = C34 | IOSTANDARD = LVCMOS25;
NET RFB_RSSI_D<4> LOC = C32 | IOSTANDARD = LVCMOS25;
NET RFB_RSSI_D<5> LOC = D31 | IOSTANDARD = LVCMOS25;
NET RFB_RSSI_D<6> LOC = G30 | IOSTANDARD = LVCMOS25;
NET RFB_RSSI_D<7> LOC = E31 | IOSTANDARD = LVCMOS25;
NET RFB_RSSI_D<8> LOC = D32 | IOSTANDARD = LVCMOS25;
NET RFB_RSSI_D<9> LOC = D34 | IOSTANDARD = LVCMOS25;
NET RFA_RSSI_D<0> LOC = E32 | IOSTANDARD = LVCMOS25;
NET RFA_RSSI_D<1> LOC = E33 | IOSTANDARD = LVCMOS25;
NET RFA_RSSI_D<2> LOC = E34 | IOSTANDARD = LVCMOS25;
NET RFA_RSSI_D<3> LOC = F30 | IOSTANDARD = LVCMOS25;
NET RFA_RSSI_D<4> LOC = F31 | IOSTANDARD = LVCMOS25;
NET RFA_RSSI_D<5> LOC = F34 | IOSTANDARD = LVCMOS25;
NET RFA_RSSI_D<6> LOC = F33 | IOSTANDARD = LVCMOS25;
NET RFA_RSSI_D<7> LOC = G31 | IOSTANDARD = LVCMOS25;
NET RFA_RSSI_D<8> LOC = G33 | IOSTANDARD = LVCMOS25;
NET RFA_RSSI_D<9> LOC = G32 | IOSTANDARD = LVCMOS25;


###### ETH_A
###### Hard_Ethernet_MAC
# This is a RGMII system
# GTX_CLK_0 = 125MHz
# LlinkTemac0_CLK = plb_v46 clk = host clock = 100MHz from clock generator
# Rx/Tx Client clocks are Rx/Tx PHY clocks so CORE Gen PHY clock constraints propagate to Rx/Tx client clock periods
# Time domain crossing constraints (DATAPATHONLY) are set for maximum bus frequency
# allowed by IP which is the maximum option in BSB. For lower bus frequency choice in BSB,
# the constraints are over constrained. Relaxing them for your system may reduce build time.

NET "*ETH_A*/hrst*" TIG;

# Locate the Tri-Mode Ethernet MAC instance
INST "*ETH_A*v6_emac" LOC = "TEMAC_X0Y0";

###############################################################################
# CLOCK CONSTRAINTS
# The following constraints are required. If you choose to not use the example
# design level of wrapper hierarchy, the net names should be translated to
# match your design.
###############################################################################

# Ethernet GTX_CLK high quality 125 MHz reference clock
NET "*/GTX_CLK_0" TNM_NET = "ref_gtx_clk";                                                 #name of signal connected to TEMAC GTX_CLK_0 input
TIMEGRP "v6_emac_v1_3_clk_ref_gtx" = "ref_gtx_clk";
TIMESPEC "TS_v6_emac_v1_3_clk_ref_gtx" = PERIOD "v6_emac_v1_3_clk_ref_gtx" 8 ns HIGH 50 %; #constant value based on constant 125 MHZ GTX clock

# Ethernet RGMII PHY-side transmit clock
# Changed NET Name - Input to bufg_tx_0
#     ___________                                         
#    |           |                 |\                     
#    | Hard Core |--- tx_clk_0_o --| >---- Tx_Cl_Clk -----
#    |___________|                 |/                     
#                                 BUFG
# 
NET "*ETH_A*/tx_cl_clk" TNM_NET = "A_phy_clk_tx";
TIMEGRP "A_v6_emac_v1_3_clk_phy_tx" = "A_phy_clk_tx";
TIMESPEC "TS_A_v6_emac_v1_3_clk_phy_tx" = PERIOD "A_v6_emac_v1_3_clk_phy_tx" 8 ns HIGH 50 %;

# Ethernet RGMII PHY-side receive clock
# Changed NET Name 
#  RGMII_RXC_0 is the name of the clock net at the TEMAC Port
#     It is the input to the IODELAY 
#        RxClientClk_0 is the name of the BUFG output clock net 
#
#                     _________      BUFR
#                    |         |      |\
#  ---RGMII_RXC_0----| IODELAY |------| >----RxClientClk_0------------
#                    |_________|      |/
#
NET "ETH_A_RGMII_RXC_0_pin" TNM_NET = "A_phy_clk_rx";
TIMEGRP "A_v6_emac_v1_3_clk_phy_rx" = "A_phy_clk_rx";
TIMESPEC "TS_A_v6_emac_v1_3_clk_phy_rx" = PERIOD "A_v6_emac_v1_3_clk_phy_rx" 7.5 ns HIGH 50 %;

# IDELAYCTRL 200 MHz reference clock
NET "clk_200*MHz*" TNM_NET  = "clk_ref_clk";                                              #name of signal connected to TEMAC REFCLK input    
TIMEGRP "ref_clk" = "clk_ref_clk";                                                                                                           
TIMESPEC "TS_ref_clk" = PERIOD "ref_clk" 5 ns HIGH 50 %;                                  #constant value based on constant 200 MHZ ref clock

# Constrain the DCR interface clock to an example frequency of 100 MHz
# Changed NET Name
# NET "DCREMACCLK" TNM_NET = "host_clock";
#NET "*ETH_A*/SPLB_CLK" TNM_NET = "host_clock";
#TIMEGRP "A_clk_host" = "A_host_clock";
#TIMESPEC "TS_A_clk_host" = PERIOD "A_clk_host" 10 ns HIGH 50 %;

###############################################################################
# PHYSICAL INTERFACE CONSTRAINTS
# The following constraints are necessary for proper operation, and are tuned
# for this example design. They should be modified to suit your design.
###############################################################################

# RGMII physical interface constraints
# -----------------------------------------------------------------------------

# Set the IDELAY and ODELAY values, tuned for this example design.
# These values should be modified to suit your design.
# original assuming equal trace lengths  INST "*rgmii?rgmii_rx_ctl_delay" IDELAY_VALUE = 13;
# original assuming equal trace lengths  INST "*rgmii?rgmii_rx_d0_delay"  IDELAY_VALUE = 13;
# original assuming equal trace lengths  INST "*rgmii?rgmii_rx_d1_delay"  IDELAY_VALUE = 13;
# original assuming equal trace lengths  INST "*rgmii?rgmii_rx_d2_delay"  IDELAY_VALUE = 13;
# original assuming equal trace lengths  INST "*rgmii?rgmii_rx_d3_delay"  IDELAY_VALUE = 13;

INST "*ETH_A*rgmii?rgmii_rx_ctl_delay" IDELAY_VALUE = 13;
INST "*ETH_A*rgmii?rgmii_rx_d0_delay"  IDELAY_VALUE = 13;
INST "*ETH_A*rgmii?rgmii_rx_d1_delay"  IDELAY_VALUE = 13;
INST "*ETH_A*rgmii?rgmii_rx_d2_delay"  IDELAY_VALUE = 13;
INST "*ETH_A*rgmii?rgmii_rx_d3_delay"  IDELAY_VALUE = 13;

INST "*ETH_A*rgmii_rxc0_delay"          IDELAY_VALUE = 0;
INST "*ETH_A*rgmii_rxc0_delay"          SIGNAL_PATTERN = CLOCK;
 
INST "*ETH_A*rgmii?rgmii_tx_clk_delay" ODELAY_VALUE = 6;
INST "*ETH_A*rgmii?rgmii_tx_clk_delay" SIGNAL_PATTERN = CLOCK;

# Group all IODELAY-related blocks to use a single IDELAYCTRL

# Change - added TNMs for trace length variations
INST "ETH_A_RGMII_RXD_0_pin[0]" TNM = "A_rgmii_rx_d0";
INST "ETH_A_RGMII_RXD_0_pin[1]" TNM = "A_rgmii_rx_d1";
INST "ETH_A_RGMII_RXD_0_pin[2]" TNM = "A_rgmii_rx_d2";
INST "ETH_A_RGMII_RXD_0_pin[3]" TNM = "A_rgmii_rx_d3";
INST "ETH_A_RGMII_RX_CTL_0_pin" TNM = "A_rgmii_rx_ctrl";

# Spec: 1.2ns setup time, 1.2ns hold time 
# The internal PHY delays were not used to derive the OFFSET constraints                                                                 
# Changed NET Name
#  This signal trace is longer than the clock trace, and arrives at the FPGA pin 64 ps after the clock
#  Therefore the offset in constraint must have less setup time than nominal
TIMEGRP "A_rgmii_rx_d0" OFFSET = IN 1.2 ns VALID 2.4 ns BEFORE "ETH_A_RGMII_RXC_0_pin" RISING;
TIMEGRP "A_rgmii_rx_d0" OFFSET = IN 1.2 ns VALID 2.4 ns BEFORE "ETH_A_RGMII_RXC_0_pin" FALLING;

#  This signal trace is shorter than the clock trace, and arrives at the FPGA pin 376 ps before the clock
#  Therefore the offset in constraint must have more setup time than nominal
TIMEGRP "A_rgmii_rx_d1" OFFSET = IN 1.2 ns VALID 2.4 ns BEFORE "ETH_A_RGMII_RXC_0_pin" RISING;
TIMEGRP "A_rgmii_rx_d1" OFFSET = IN 1.2 ns VALID 2.4 ns BEFORE "ETH_A_RGMII_RXC_0_pin" FALLING;

#  This signal trace is shorter than the clock trace, and arrives at the FPGA pin 372 ps before the clock
#  Therefore the offset in constraint must have more setup time than nominal
TIMEGRP "A_rgmii_rx_d2" OFFSET = IN 1.2 ns VALID 2.4 ns BEFORE "ETH_A_RGMII_RXC_0_pin" RISING;
TIMEGRP "A_rgmii_rx_d2" OFFSET = IN 1.2 ns VALID 2.4 ns BEFORE "ETH_A_RGMII_RXC_0_pin" FALLING;

#  This signal trace is shorter than the clock trace, and arrives at the FPGA pin 115 ps before the clock
#  Therefore the offset in constraint must have more setup time than nominal
TIMEGRP "A_rgmii_rx_d3" OFFSET = IN 1.2 ns VALID 2.4 ns BEFORE "ETH_A_RGMII_RXC_0_pin" RISING;
TIMEGRP "A_rgmii_rx_d3" OFFSET = IN 1.2 ns VALID 2.4 ns BEFORE "ETH_A_RGMII_RXC_0_pin" FALLING;

#  This signal trace is shorter than the clock trace, and arrives at the FPGA pin 292 ps before the clock
#  Therefore the offset in constraint must have more setup time than nominal
TIMEGRP "A_rgmii_rx_ctrl" OFFSET = IN 1.2 ns VALID 2.4 ns BEFORE "ETH_A_RGMII_RXC_0_pin" RISING;
TIMEGRP "A_rgmii_rx_ctrl" OFFSET = IN 1.2 ns VALID 2.4 ns BEFORE "ETH_A_RGMII_RXC_0_pin" FALLING;


NET "*ETH_A*/LlinkTemac0_CLK" TNM_NET = "A_LLCLK0"; #name of signal connected to TEMAC LlinkTemac0_CLK input
NET "*ETH_A*/SPLB_Clk" TNM_NET = "A_PLBCLK"; #name of signal connected to TEMAC SPLB_Clk input
NET "*ETH_A*/REFCLK" TNM_NET = "A_REFCLK"; #name of signal connected to TEMAC REFCLK input

TIMESPEC "TS_A_LL_CLK0_2_RX_CLIENT_CLK0"  = FROM A_LLCLK0 TO A_phy_clk_rx 8000 ps DATAPATHONLY; #constant value based on Ethernet clock                 
TIMESPEC "TS_A_LL_CLK0_2_TX_CLIENT_CLK0"  = FROM A_LLCLK0 TO A_phy_clk_tx 8000 ps DATAPATHONLY; #constant value based on Ethernet clock             
TIMESPEC "TS_A_RX_CLIENT_CLK0_2_LL_CLK0"  = FROM A_phy_clk_rx TO A_LLCLK0 8000 ps DATAPATHONLY; #varies based on period of LocalLink clock           
TIMESPEC "TS_A_TX_CLIENT_CLK0_2_LL_CLK0"  = FROM A_phy_clk_tx TO A_LLCLK0 8000 ps DATAPATHONLY; #varies based on period of LocalLink clock           

TIMESPEC "TS_A_REF_CLK_2_PLB_CLIENT_CLK"  = FROM A_REFCLK TO A_PLBCLK 8000 ps DATAPATHONLY; #varies based on period of PLB clock                        
TIMESPEC "TS_A_PLB_CLIENT_CLK_2_REF_CLK"  = FROM A_PLBCLK TO A_REFCLK 5000 ps DATAPATHONLY; #constant value based on constant 200 MHZ ref clock         

TIMESPEC "TS_A_REF_CLK_2_TX_CLIENT_CLK0"  = FROM A_REFCLK TO A_phy_clk_tx 8000 ps DATAPATHONLY; #constant value based on Ethernet clock                       
TIMESPEC "TS_A_TX_CLIENT_CLK0_2_REF_CLK"  = FROM A_phy_clk_tx TO A_REFCLK 5000 ps DATAPATHONLY; #constant value based on constant 200 MHZ ref clock           

TIMESPEC "TS_A_REF_CLK_2_RX_CLIENT_CLK0"  = FROM A_REFCLK TO A_phy_clk_rx 8000 ps DATAPATHONLY; #constant value based on Ethernet clock                
TIMESPEC "TS_A_RX_CLIENT_CLK0_2_REF_CLK"  = FROM A_phy_clk_rx TO A_REFCLK 5000 ps DATAPATHONLY; #constant value based on constant 200 MHZ ref clock    



###### ETH_B
###### Hard_Ethernet_MAC
# This is a RGMII system
# GTX_CLK_0 = 125MHz
# LlinkTemac0_CLK = plb_v46 clk = host clock = 100MHz from clock generator
# Rx/Tx Client clocks are Rx/Tx PHY clocks so CORE Gen PHY clock constraints propagate to Rx/Tx client clock periods
# Time domain crossing constraints (DATAPATHONLY) are set for maximum bus frequency
# allowed by IP which is the maximum option in BSB. For lower bus frequency choice in BSB,
# the constraints are over constrained. Relaxing them for your system may reduce build time.

NET "*ETH_B*/hrst*" TIG;

# Locate the Tri-Mode Ethernet MAC instance
INST "*ETH_B*v6_emac" LOC = "TEMAC_X0Y1";

###############################################################################
# CLOCK CONSTRAINTS
# The following constraints are required. If you choose to not use the example
# design level of wrapper hierarchy, the net names should be translated to
# match your design.
###############################################################################

# Ethernet RGMII PHY-side transmit clock
# Changed NET Name - Input to bufg_tx_0
#     ___________                                         
#    |           |                 |\                     
#    | Hard Core |--- tx_clk_0_o --| >---- Tx_Cl_Clk -----
#    |___________|                 |/                     
#                                 BUFG
# 
NET "*ETH_B*/tx_cl_clk" TNM_NET = "B_phy_clk_tx";
TIMEGRP "B_v6_emac_v1_3_clk_phy_tx" = "B_phy_clk_tx";
TIMESPEC "TS_B_v6_emac_v1_3_clk_phy_tx" = PERIOD "B_v6_emac_v1_3_clk_phy_tx" 8 ns HIGH 50 %;

# Ethernet RGMII PHY-side receive clock
# Changed NET Name 
#  RGMII_RXC_0 is the name of the clock net at the TEMAC Port
#     It is the input to the IODELAY 
#        RxClientClk_0 is the name of the BUFG output clock net 
#
#                     _________      BUFR
#                    |         |      |\
#  ---RGMII_RXC_0----| IODELAY |------| >----RxClientClk_0------------
#                    |_________|      |/
#
NET "ETH_B_RGMII_RXC_0_pin" TNM_NET = "B_phy_clk_rx";
TIMEGRP "B_v6_emac_v1_3_clk_phy_rx" = "B_phy_clk_rx";
TIMESPEC "TS_B_v6_emac_v1_3_clk_phy_rx" = PERIOD "B_v6_emac_v1_3_clk_phy_rx" 7.5 ns HIGH 50 %;

# Constrain the DCR interface clock to an example frequency of 100 MHz
# Changed NET Name
# NET "DCREMACCLK" TNM_NET = "host_clock";
NET "*ETH_B*/SPLB_CLK" TNM_NET = "host_clock";
TIMEGRP "B_clk_host" = "B_host_clock";
TIMESPEC "TS_B_clk_host" = PERIOD "B_clk_host" 10 ns HIGH 50 %;

###############################################################################
# PHYSICAL INTERFACE CONSTRAINTS
# The following constraints are necessary for proper operation, and are tuned
# for this example design. They should be modified to suit your design.
###############################################################################

# RGMII physical interface constraints
# -----------------------------------------------------------------------------

# Set the IDELAY and ODELAY values, tuned for this example design.
# These values should be modified to suit your design.
# original assuming equal trace lengths  INST "*rgmii?rgmii_rx_ctl_delay" IDELAY_VALUE = 13;
# original assuming equal trace lengths  INST "*rgmii?rgmii_rx_d0_delay"  IDELAY_VALUE = 13;
# original assuming equal trace lengths  INST "*rgmii?rgmii_rx_d1_delay"  IDELAY_VALUE = 13;
# original assuming equal trace lengths  INST "*rgmii?rgmii_rx_d2_delay"  IDELAY_VALUE = 13;
# original assuming equal trace lengths  INST "*rgmii?rgmii_rx_d3_delay"  IDELAY_VALUE = 13;

INST "*ETH_B*rgmii?rgmii_rx_ctl_delay" IDELAY_VALUE = 13;
INST "*ETH_B*rgmii?rgmii_rx_d0_delay"  IDELAY_VALUE = 13;
INST "*ETH_B*rgmii?rgmii_rx_d1_delay"  IDELAY_VALUE = 13;
INST "*ETH_B*rgmii?rgmii_rx_d2_delay"  IDELAY_VALUE = 13;
INST "*ETH_B*rgmii?rgmii_rx_d3_delay"  IDELAY_VALUE = 13;

INST "*ETH_B*rgmii_rxc0_delay"          IDELAY_VALUE = 0;
INST "*ETH_B*rgmii_rxc0_delay"          SIGNAL_PATTERN = CLOCK;
 
INST "*ETH_B*rgmii?rgmii_tx_clk_delay" ODELAY_VALUE = 6;
INST "*ETH_B*rgmii?rgmii_tx_clk_delay" SIGNAL_PATTERN = CLOCK;

# Group all IODELAY-related blocks to use a single IDELAYCTRL

# Change - added TNMs for trace length variations
INST "ETH_B_RGMII_RXD_0_pin[0]" TNM = "B_rgmii_rx_d0";
INST "ETH_B_RGMII_RXD_0_pin[1]" TNM = "B_rgmii_rx_d1";
INST "ETH_B_RGMII_RXD_0_pin[2]" TNM = "B_rgmii_rx_d2";
INST "ETH_B_RGMII_RXD_0_pin[3]" TNM = "B_rgmii_rx_d3";
INST "ETH_B_RGMII_RX_CTL_0_pin" TNM = "B_rgmii_rx_ctrl";

# Spec: 1.2ns setup time, 1.2ns hold time 
# The internal PHY delays were not used to derive the OFFSET constraints                                                                 
# Changed NET Name
#  This signal trace is longer than the clock trace, and arrives at the FPGA pin 64 ps after the clock
#  Therefore the offset in constraint must have less setup time than nominal
TIMEGRP "B_rgmii_rx_d0" OFFSET = IN 1.2 ns VALID 2.4 ns BEFORE "ETH_B_RGMII_RXC_0_pin" RISING;
TIMEGRP "B_rgmii_rx_d0" OFFSET = IN 1.2 ns VALID 2.4 ns BEFORE "ETH_B_RGMII_RXC_0_pin" FALLING;

#  This signal trace is shorter than the clock trace, and arrives at the FPGA pin 376 ps before the clock
#  Therefore the offset in constraint must have more setup time than nominal
TIMEGRP "B_rgmii_rx_d1" OFFSET = IN 1.2 ns VALID 2.4 ns BEFORE "ETH_B_RGMII_RXC_0_pin" RISING;
TIMEGRP "B_rgmii_rx_d1" OFFSET = IN 1.2 ns VALID 2.4 ns BEFORE "ETH_B_RGMII_RXC_0_pin" FALLING;

#  This signal trace is shorter than the clock trace, and arrives at the FPGA pin 372 ps before the clock
#  Therefore the offset in constraint must have more setup time than nominal
TIMEGRP "B_rgmii_rx_d2" OFFSET = IN 1.2 ns VALID 2.4 ns BEFORE "ETH_B_RGMII_RXC_0_pin" RISING;
TIMEGRP "B_rgmii_rx_d2" OFFSET = IN 1.2 ns VALID 2.4 ns BEFORE "ETH_B_RGMII_RXC_0_pin" FALLING;

#  This signal trace is shorter than the clock trace, and arrives at the FPGA pin 115 ps before the clock
#  Therefore the offset in constraint must have more setup time than nominal
TIMEGRP "B_rgmii_rx_d3" OFFSET = IN 1.2 ns VALID 2.4 ns BEFORE "ETH_B_RGMII_RXC_0_pin" RISING;
TIMEGRP "B_rgmii_rx_d3" OFFSET = IN 1.2 ns VALID 2.4 ns BEFORE "ETH_B_RGMII_RXC_0_pin" FALLING;

#  This signal trace is shorter than the clock trace, and arrives at the FPGA pin 292 ps before the clock
#  Therefore the offset in constraint must have more setup time than nominal
TIMEGRP "B_rgmii_rx_ctrl" OFFSET = IN 1.2 ns VALID 2.4 ns BEFORE "ETH_B_RGMII_RXC_0_pin" RISING;
TIMEGRP "B_rgmii_rx_ctrl" OFFSET = IN 1.2 ns VALID 2.4 ns BEFORE "ETH_B_RGMII_RXC_0_pin" FALLING;


NET "*ETH_B*/LlinkTemac0_CLK" TNM_NET = "B_LLCLK0"; #name of signal connected to TEMAC LlinkTemac0_CLK input
NET "*ETH_B*/SPLB_Clk" TNM_NET = "B_PLBCLK"; #name of signal connected to TEMAC SPLB_Clk input

TIMESPEC "TS_B_LL_CLK0_2_RX_CLIENT_CLK0"  = FROM B_LLCLK0 TO B_phy_clk_rx 8000 ps DATAPATHONLY; #constant value based on Ethernet clock                 
TIMESPEC "TS_B_LL_CLK0_2_TX_CLIENT_CLK0"  = FROM B_LLCLK0 TO B_phy_clk_tx 8000 ps DATAPATHONLY; #constant value based on Ethernet clock             
TIMESPEC "TS_B_RX_CLIENT_CLK0_2_LL_CLK0"  = FROM B_phy_clk_rx TO B_LLCLK0 8000 ps DATAPATHONLY; #varies based on period of LocalLink clock           
TIMESPEC "TS_B_TX_CLIENT_CLK0_2_LL_CLK0"  = FROM B_phy_clk_tx TO B_LLCLK0 8000 ps DATAPATHONLY; #varies based on period of LocalLink clock       

###### DDR3_2GB_SODIMM
#2012-Apr-2:
# -Started with old UCF snippet from early FPGA pinout testing
# -Updated LOC constraints to match MIG 13.4 design which met timing for 2GB SO-DIMM (-1 @ 400MHz, -2 @ 533MHz)

###### DDR3_SDRAM

# Constrain BUFR clocks used to synchronize data from IOB to fabric logic
# Note that ISE cannot infer this from other PERIOD constraints because
# of the use of OSERDES blocks in the BUFR clock generation path
NET "*/mpmc_core_0/gen_v6_ddr3_phy.mpmc_phy_if_0/clk_rsync[?]" TNM_NET = TNM_clk_rsync;
TIMESPEC "TS_clk_rsync" = PERIOD "TNM_clk_rsync" 5000 ps;       # This is over-constraint for 200MHz, user can relax it to match mpmc_clk0
 
# Paths between DQ/DQS ISERDES.Q outputs and CLB flops clocked by falling 
# edge of BUFR will by design only be used if DYNCLKDIVSEL is asserted for 
# that particular flop. Mark this path as being a full-cycle, rather than 
# a half cycle path for timing purposes. NOTE: This constraint forces full-
# cycle timing to be applied globally for all rising->falling edge paths 
# in all resynchronizaton clock domains. If the user had modified the logic
# in the resync clock domain such that other rising->falling edge paths 
# exist, then constraint below should be modified to utilize pattern 
# matching to specific affect only the DQ/DQS ISERDES.Q outputs
TIMEGRP "TG_clk_rsync_rise" = RISING  "TNM_clk_rsync";
TIMEGRP "TG_clk_rsync_fall" = FALLING "TNM_clk_rsync";
TIMESPEC "TS_clk_rsync_rise_to_fall" =    FROM "TG_clk_rsync_rise" TO "TG_clk_rsync_fall" 5000 ps;    # This is over-constraint for 200MHz, user can relax it to match mpmc_clk0
 
# Signal to select between controller and physical layer signals. Four divided by two clock
# cycles (4 memory clock cycles) are provided by design for the signal to settle down.
# Used only by the phy modules.
INST "*/mpmc_core_0/gen_v6_ddr3_phy.mpmc_phy_if_0/u_phy_init/u_ff_phy_init_data_sel" TNM = "TNM_PHY_INIT_SEL";
TIMESPEC "TS_MC_PHY_INIT_SEL" = FROM "TNM_PHY_INIT_SEL" TO FFS = 10000 ps;                         # This is over-constraint, user can relax it to match 4 memory clock cycles

#Internal Vref
CONFIG INTERNAL_VREF_BANK22=0.75;
CONFIG INTERNAL_VREF_BANK23=0.75;
CONFIG INTERNAL_VREF_BANK33=0.75;

#DCI Cascading
CONFIG DCI_CASCADE = "23 22";

#BUFR IOBs (must be unconnected in FPGA and PCB)
CONFIG PROHIBIT = AH17,AP20;

#BUFIO IOBs (must be unconnected in FPGA and PCB)
CONFIG PROHIBIT = AC13,AD12,AF19,AF20,AH23,AK27,AN27,AP11;

######################################################################################
##Place RSYNC OSERDES and IODELAY:                                                  ##
######################################################################################

#MPMC as of EDK 13.4 only supports 32-bit memories
##Site: AH17 -- Bank 32
#INST "*/u_phy_read/u_phy_rdclk_gen/gen_loop_col1.u_oserdes_rsync" LOC = "OLOGIC_X2Y23";
#INST "*/u_phy_read/u_phy_rdclk_gen/gen_loop_col1.u_odelay_rsync" LOC = "IODELAY_X2Y23";
#INST "*/u_phy_read/u_phy_rdclk_gen/gen_loop_col1.u_bufr_rsync" LOC = "BUFR_X2Y1";

##Site: AP20 -- Bank 22
INST "*/u_phy_read/u_phy_rdclk_gen/gen_loop_col0.u_oserdes_rsync" LOC = "OLOGIC_X1Y21";
INST "*/u_phy_read/u_phy_rdclk_gen/gen_loop_col0.u_odelay_rsync" LOC = "IODELAY_X1Y21";
INST "*/u_phy_read/u_phy_rdclk_gen/gen_loop_col0.u_bufr_rsync" LOC = "BUFR_X1Y1";


######################################################################################
##Place CPT OSERDES and IODELAY:                                                    ##
######################################################################################

##Site: AH23 -- Bank 23
INST "*/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt[0].u_oserdes_cpt" LOC = "OLOGIC_X1Y57";
INST "*/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt[0].u_odelay_cpt" LOC = "IODELAY_X1Y57";

##Site: AK27 -- Bank 23
INST "*/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt[1].u_oserdes_cpt" LOC = "OLOGIC_X1Y59";
INST "*/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt[1].u_odelay_cpt" LOC = "IODELAY_X1Y59";

##Site: AN27 -- Bank 23
INST "*/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt[2].u_oserdes_cpt" LOC = "OLOGIC_X1Y61";
INST "*/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt[2].u_odelay_cpt" LOC = "IODELAY_X1Y61";

##Site: AF19 -- Bank 22
INST "*/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt[3].u_oserdes_cpt" LOC = "OLOGIC_X1Y23";
INST "*/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt[3].u_odelay_cpt" LOC = "IODELAY_X1Y23";

#MPMC as of EDK 13.4 only supports 32-bit memories
##Site: AF20 -- Bank 22
#INST "*/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt[4].u_oserdes_cpt" LOC = "OLOGIC_X1Y17";
#INST "*/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt[4].u_odelay_cpt" LOC = "IODELAY_X1Y17";

##Site: AP11 -- Bank 33
#INST "*/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt[5].u_oserdes_cpt" LOC = "OLOGIC_X2Y57";
#INST "*/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt[5].u_odelay_cpt" LOC = "IODELAY_X2Y57";

##Site: AC13 -- Bank 33
#INST "*/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt[6].u_oserdes_cpt" LOC = "OLOGIC_X2Y61";
#INST "*/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt[6].u_odelay_cpt" LOC = "IODELAY_X2Y61";

##Site: AD12 -- Bank 33
#INST "*/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt[7].u_oserdes_cpt" LOC = "OLOGIC_X2Y59";
#INST "*/u_phy_read/u_phy_rdclk_gen/gen_ck_cpt[7].u_odelay_cpt" LOC = "IODELAY_X2Y59";


